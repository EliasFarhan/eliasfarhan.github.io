<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GPR5100 - Rollback: GPR5100 - Rollback Game Index Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GPR5100 - Rollback
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">GPR5100 - Rollback Game Index Page </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p >This is the documentation of the GPR5100 - Rollback Game sommative project. It is a simple asteroid-like online multiplayer game using rollback mechanisms for client-side prediction and server authorative validation.</p>
<h1><a class="anchor" id="install_sec"></a>
Installation</h1>
<p >To start working on the project, you are required CMake and vcpkg. </p>
<h2><a class="anchor" id="windows"></a>
Windows</h2>
<p >On Windows, you can use Visual Studio 2022 that supports C++20 pretty well. </p>
<h2><a class="anchor" id="ubuntu"></a>
Ubuntu</h2>
<p >Tested on Ubuntu 20.04 with gcc-10 and g++-10 and Ubuntu 22.04. To install the required packages for vcpkg: </p><div class="fragment"><div class="line">sudo apt install autoconf libtool libsfml-dev libxrandr-dev libudev-dev</div>
</div><!-- fragment --><p> In command-line, you can setup cmake and make with: </p><div class="fragment"><div class="line">cmake -DCMAKE_TOOLCHAIN_FILE=&lt;VCPKG_HOME&gt;/scripts/buildsystems/vcpkg.cmake .. <span class="comment">//-DCMAKE_BUILD_TYPE= Debug/RelWithDebInfo/Release</span></div>
<div class="line">make -j 4</div>
</div><!-- fragment --> <h1><a class="anchor" id="ecs"></a>
ECS implementation</h1>
<p >ECS or Entity-Component-System is a pattern of structuring game world objects and their components. In our purpose, it allows to simply replicate the game data as each component is stored by type. </p>
<h2><a class="anchor" id="entity_manager"></a>
Entity Manager</h2>
<p >The <a class="el" href="classcore_1_1_entity_manager.html" title="Manages the entities in an array using bitwise operations to know if it has components.">core::EntityManager</a> is the main class of our ECS implementation. From the EntityManager, you can get if an Entity exists, if it contains a certain Component and you can destroy it.</p>
<p >The implementation is pretty straightforward. Using bitwise operation, we store the Component type in a unique EntityMask. This saves a lot of memory and is pretty fast to get the result.</p>
<p >However, you cannot get access to the specific Component of an Entity. For that, you need to get access to its ComponentManager.</p>
<p >Here are the typical use-case of the EntityManager: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> entity = entityManager_.CreateEntity();</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keywordflow">if</span>(entityManager_.HasComponent(entity, <span class="keyword">static_cast&lt;</span><a class="code hl_typedef" href="entity_8h.html#a1761ce034a166d738c0f92d698c7a52a">core::EntityMask</a><span class="keyword">&gt;</span>(core::ComponentType::TRANSFORM)))</div>
<div class="line">{</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line">entityManager_.DestroyEntity(entity);</div>
<div class="ttc" id="aentity_8h_html_a1761ce034a166d738c0f92d698c7a52a"><div class="ttname"><a href="entity_8h.html#a1761ce034a166d738c0f92d698c7a52a">core::EntityMask</a></div><div class="ttdeci">std::uint32_t EntityMask</div><div class="ttdoc">EntityMask is the type used to define the bitwise mask of an Entity. It is used to know what Componen...</div><div class="ttdef"><b>Definition:</b> entity.h:22</div></div>
</div><!-- fragment --> <h2><a class="anchor" id="component_manager"></a>
Component Manager</h2>
<p >The <a class="el" href="classcore_1_1_component_manager.html" title="ComponentManager is a class that owns Component in a contiguous array. Component indexing is done wit...">core::ComponentManager</a> is a template class that automatically generates a std::vector of the given component type T. It requires an <a class="el" href="classcore_1_1_entity_manager.html" title="Manages the entities in an array using bitwise operations to know if it has components.">core::EntityManager</a>, such that when adding or removing a component, the <a class="el" href="classcore_1_1_component_manager.html" title="ComponentManager is a class that owns Component in a contiguous array. Component indexing is done wit...">core::ComponentManager</a> can notify the <a class="el" href="classcore_1_1_entity_manager.html" title="Manages the entities in an array using bitwise operations to know if it has components.">core::EntityManager</a> of the change. Here are the typical use-case: </p><div class="fragment"><div class="line"><span class="comment">//With core::Entity entity and core::ComponentManager spriteManager_</span></div>
<div class="line">spriteManager_.AddComponent(entity);</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">auto</span>&amp; sprite = spriteManager_.GetComponent(entity);</div>
<div class="line"><span class="comment">//... Do things with sprite</span></div>
<div class="line">spriteMManager_.RemoveComponent(entity);</div>
</div><!-- fragment --> <h2><a class="anchor" id="sprite_manager"></a>
Sprite Manager</h2>
<p >The <a class="el" href="classcore_1_1_sprite_manager.html" title="SpriteManager is a ComponentManager that manages sprites, order by greater entity index,...">core::SpriteManager</a> is a <a class="el" href="classcore_1_1_component_manager.html" title="ComponentManager is a class that owns Component in a contiguous array. Component indexing is done wit...">core::ComponentManager</a> that owns the sprites in the game. Sprites are using sf::Sprite from SFML to draw on the window.</p>
<p >Sprite draw ordering works with <a class="el" href="entity_8h.html#aebe678aa1c193803d80b4ac35e8c6825" title="Entity is the type used to define an game world entity. An Entity is just an index,...">core::Entity</a> ordering. It means that the background should be the first entity to spawn because it will drawn first, therefore behind the next sprites.</p>
<p >Sprites are centered on the position of the <a class="el" href="classcore_1_1_position_manager.html" title="PositionManager is a ComponentManager that holds positions in 2d space. Positions are in physics spac...">core::PositionManager</a> by default. </p>
<h2><a class="anchor" id="physics_manager"></a>
Physics Manager</h2>
<p >The <a class="el" href="classgame_1_1_physics_manager.html" title="PhysicsManager is a class that holds both BodyManager and BoxManager and manages the physics fixed up...">game::PhysicsManager</a> is a class that contains two <a class="el" href="classcore_1_1_component_manager.html" title="ComponentManager is a class that owns Component in a contiguous array. Component indexing is done wit...">core::ComponentManager</a>:</p><ul>
<li><a class="el" href="classgame_1_1_body_manager.html" title="BodyManager is a ComponentManager that holds all the Body in the world.">game::BodyManager</a> owns the <a class="el" href="structgame_1_1_body.html" title="Body is a class that represents a rigid body.">game::Body</a> (or rigid bodies) of the physics engine.</li>
<li><a class="el" href="classgame_1_1_box_manager.html" title="BoxManager is a ComponentManager that holds all the Box in the world.">game::BoxManager</a> owns the <a class="el" href="structgame_1_1_box.html" title="Box is a class that represents an axis-aligned box collider.">game::Box</a> (or box colliders) of the physics engine.</li>
</ul>
<p >The Physics Engine is a REALLY simple implementation of basic box triggering.</p>
<p >When a trigger occurs, the <a class="el" href="classgame_1_1_physics_manager.html" title="PhysicsManager is a class that holds both BodyManager and BoxManager and manages the physics fixed up...">game::PhysicsManager</a> will call the OnTrigger method all its <a class="el" href="classgame_1_1_on_trigger_interface.html" title="OnTriggerInterface is an interface for classes that needs to be called when two boxes are in contact....">game::OnTriggerInterface</a>. To register a <a class="el" href="classgame_1_1_on_trigger_interface.html" title="OnTriggerInterface is an interface for classes that needs to be called when two boxes are in contact....">game::OnTriggerInterface</a>, you have to give it to the RegisterTriggerListener method. </p>
<h2><a class="anchor" id="transform_manager"></a>
Transform Manager</h2>
<p >The <a class="el" href="classcore_1_1_transform_manager.html" title="TransformManager is a class combining a PositionManager, a ScaleManager and a RotationManager in one.">core::TransformManager</a> is a class that contains three <a class="el" href="classcore_1_1_component_manager.html" title="ComponentManager is a class that owns Component in a contiguous array. Component indexing is done wit...">core::ComponentManager</a>:</p><ul>
<li><a class="el" href="classcore_1_1_position_manager.html" title="PositionManager is a ComponentManager that holds positions in 2d space. Positions are in physics spac...">core::PositionManager</a> owns the positions in meter of all entities, both used in physics and graphics (converted to pixel with pixelToMeter).</li>
<li><a class="el" href="classcore_1_1_scale_manager.html" title="ScaleManager is a ComponentManager that holds the scale ratio in x and y. By default,...">core::ScaleManager</a> owns the scaling ratios of all entities. This only applies to the graphics part of the game, NOT the physics part.</li>
<li><a class="el" href="classcore_1_1_rotation_manager.html" title="RotationManager is a ComponentManager that holds the Degree angle.">core::RotationManager</a> owns the angles (in <a class="el" href="classcore_1_1_degree.html" title="Degree is an utility class that describes degree angles (0 to 360). It can be easily converted to Rad...">core::Degree</a>) of all entites. This only applies to the graphics part of the game, NOT the physics. </li>
</ul>
<h1><a class="anchor" id="netcode"></a>
Netcode</h1>
<p >This project netcode is pretty simple, but should work for any simple game project. </p>
<h2><a class="anchor" id="server_connection"></a>
Connecting to the server</h2>
<p >When a client wants to connect to the server to be able to join a game, they will have to connect both in TCP and UDP. This is the step-by-step:</p><ol type="1">
<li>The Client connects to the TCP IP address and port and sends a JOIN packet</li>
<li>The Server answers with a JOIN_ACK packet containing the UDP port.</li>
<li>The Client sends a JOIN packet on the UDP channel.</li>
<li>The Server answers with a JOIN_ACK on the UDP channel. The Client is then a valid connected client. </li>
</ol>
<h2><a class="anchor" id="spawn_player"></a>
Spawn player</h2>
<p >When a new player client connects to the server, their player character is also spawned as well. To spawn all player characters when a new client connects, the server sends the <a class="el" href="structgame_1_1_spawn_player_packet.html" title="SpawnPlayerPacket is a TCP Packet sent by the server to all clients to notify of the spawn of a new p...">game::SpawnPlayerPacket</a> from all current player characters to all player clients. Spawn positions, rotations and colors are hardcoded in the <a href="game__globals_8h.html">game_globals.h</a> header file. </p>
<h2><a class="anchor" id="start_game"></a>
Starting the game</h2>
<p >When all players are connected, the server automatically send a <a class="el" href="structgame_1_1_start_game_packet.html" title="StartGamePacket is a TCP Packet send by the server to start a game at a given time.">game::StartGamePacket</a> to each player through the TCP channel. Each client will then wait about <a href="game__globals_8h.html">game::startDelay</a> milliseconds before starting their game session. </p>
<h2><a class="anchor" id="send_input"></a>
Sending player inputs</h2>
<p >Each frame, the game sends the current player inputs (<a class="el" href="structgame_1_1_player_input_packet.html" title="PlayerInputPacket is a UDP Packet sent by the player client and then replicated by the server to all ...">game::PlayerInputPacket</a>), as well as the last <a href="game__globals_8h.html">game::maxInputNmb</a> inputs in an UDP packet. </p>
<h2><a class="anchor" id="validate_frame"></a>
Validating the frame</h2>
<p >When the server finally receives all the player inputs for a specific frame, it will automatically validate the specific frame and will update its lastValidateFrame_ to the new specific frame. It will then sends a <a class="el" href="structgame_1_1_validate_frame_packet.html" title="ValidateFramePacket is an UDP packet that is sent by the server to validate the last physics state of...">game::ValidateFramePacket</a> to all clients.</p>
<p >On the client side, when receiving a <a class="el" href="structgame_1_1_validate_frame_packet.html" title="ValidateFramePacket is an UDP packet that is sent by the server to validate the last physics state of...">game::ValidateFramePacket</a>, the client will calculate the frame physics status and check that the result is the same as the server one. If it is not the case, there is desynchronisation and the game must end! </p>
<h2><a class="anchor" id="ping"></a>
Ping</h2>
<p >It is always important to know the current round trip time between a client and a server. The ping system is pretty simple. The client sends a PING Packet (<a class="el" href="structgame_1_1_ping_packet.html" title="PingPacket is an UDP Packet sent by the client to the server and resend by the server to measure the ...">game::PingPacket</a>) to the server containing the current time and the server sends the same Packet back. When the client gets the <a class="el" href="structgame_1_1_ping_packet.html" title="PingPacket is an UDP Packet sent by the client to the server and resend by the server to measure the ...">game::PingPacket</a> back, it can calculate the time it took for the Packet to do the round trip (RTT).</p>
<p >We then use TCP Retransmission Timer to calculate srtt and rttvar to get an idea of the average and variability of the packet. </p>
<h2><a class="anchor" id="win_game"></a>
Win game</h2>
<p >When the server validates the frame where a win/lose condition occurs, it sends a <a class="el" href="structgame_1_1_win_game_packet.html" title="WinGamePacket is a TCP Packet sent by the server to notify the clients that a certain player has won.">game::WinGamePacket</a> on a reliable channel to all the clients with the info on the winning player. This allows all clients to stop their game loop and show an ending message (You won! or The other player won!). </p>
<h2><a class="anchor" id="net_simulation"></a>
Net Simulation</h2>
<p >Instead of always setting up a server and clients, this project allows to use a single executable with a network simulation. It does not use SFML sockets and packets, but simulates delays and packet loss (which can be customized in the UI, image below). It uses the same server and client game managers so you do not need to change anything. It also allows to test the limits of your netcode by increasing the delay estimated time as well as variability without requiring a specific network for that. It is available using the "debug" executable. </p><div class="image">
<img src="simulation_ui.png" alt=""/>
</div>
 <h1><a class="anchor" id="rollback"></a>
Rollback mechanisms</h1>
<h2><a class="anchor" id="rollback_how"></a>
How the rollback works?</h2>
<p >At any time, each client have the game world state of two points in time:</p><ul>
<li>Last Validated Frame</li>
<li>Current Frame (except the server) The server only stores the last validated frame's physics state. </li>
</ul>
<h2><a class="anchor" id="current_frame"></a>
Client Current Frame</h2>
<p >To allow real time illusion, the client controls its player character in real time without waiting the validation of the server. For other clients, the rollback manager will simply repeat the last received inputs.</p>
<p >After receiving other clients inputs, the rollback manager will run all the FixedUpdate methods between the last validated frame and the current frame before running the new current frame. </p>
<h2><a class="anchor" id="physics_checksum"></a>
Validating a Frame</h2>
<p >When validating a frame, the server calculates the new physics state and will then generate a checksum (a 16-bit number) per player of the player character positions, rotations and velocities (linear and angular). This number is sent in the game::ValidateStatePacket with the validated frame index.</p>
<p >The clients will then validate the frame by calculating the physics state up to the server validated frame and will then compare the checksums values. If the values differ, it is the end of the game, because the physics state of the client is in desync, meaning that the physics simulation was not determinist compare to the other process/host. </p>
<h2><a class="anchor" id="destroy_entity"></a>
Create And Destroy Entities</h2>
<p >On the client side, due to the delta time between the last validate frame from the server and the current frame on the client, we cannot be sure that an entity is actually created or destroyed when creating or destroying an entity. It means that we have to wait for the server to confirm the frame where an entitiy is created or destroyed, before actually create or destroy the entity.</p>
<p >For entity creation, it is a rather easy problem to solve. We just have to store when a entity is created (<a class="el" href="structgame_1_1_created_entity.html" title="CreatedEntity is a struct that contains information on the newly created entities....">game::CreatedEntity</a> struct). Before calculating a new current frame from the last validated frame or when validating a frame, we just check this frame time with the last validated frame and if it is younger, we simply destroy the entity (because it will be created again when simulating).</p>
<p >For entity destruction, the chosen solution do not actually destroy the entity. We simply add a DESTROY flag in the <a class="el" href="classcore_1_1_entity_manager.html" title="Manages the entities in an array using bitwise operations to know if it has components.">core::EntityManager</a> (like an empty Component) when simulating a new frame. If we are validating a frame, we simply destroy the entity. This means that the FixedUpdate methods have to check both if an entity exists and that there is no DESTROY component. </p>
<h1><a class="anchor" id="game_manager"></a>
GameManager</h1>
<p >The game is managed in the <a class="el" href="classgame_1_1_game_manager.html" title="GameManager is a class which manages the state of the game. It is shared between the client and the s...">game::GameManager</a>. However, depending if the application is client- or server-side, the requirements on the GameManager are completely different. </p>
<h2><a class="anchor" id="server_game_manager"></a>
Server GameManager</h2>
<p >Due to the nature of the server-side, the server <a class="el" href="classgame_1_1_game_manager.html" title="GameManager is a class which manages the state of the game. It is shared between the client and the s...">game::GameManager</a> does not need to care about the graphical part of the game (managed in the Update method), only the physical part (mostly managed in the FixedUpdate). It does not have an Update method, as the physics state validation is only done when receiving all the player inputs of a certain frame. The server only reacts to received packets to move forward in the game. Obviously, the server is always back in the game past compared to the clients, but it is authorative.</p>
<p >For an event to only happen on the server side, one must implement it in the <a class="el" href="classgame_1_1_server.html" title="Server is an interface to a network or simulated server. It owns a simple GameManager.">game::Server</a> class (NOT in the <a class="el" href="classgame_1_1_game_manager.html" title="GameManager is a class which manages the state of the game. It is shared between the client and the s...">game::GameManager</a>, because it will be used in the <a class="el" href="classgame_1_1_client_game_manager.html" title="ClientGameManager is a class that inherits from GameManager by adding the visual part and specific im...">game::ClientGameManager</a> as well). </p>
<h2><a class="anchor" id="client_game_manager"></a>
Client GameManager</h2>
<p >The <a class="el" href="classgame_1_1_client_game_manager.html" title="ClientGameManager is a class that inherits from GameManager by adding the visual part and specific im...">game::ClientGameManager</a> inherits from the server <a class="el" href="classgame_1_1_game_manager.html" title="GameManager is a class which manages the state of the game. It is shared between the client and the s...">game::GameManager</a> and extends its features with graphical interface and real time client requirements. It means that like the server, it manages the receiving inputs, but at the same time, it also update the graphical part of the game in the Update method while updating the rollbacked phyiscal state in a continuous FixedUpdate way (it does not wait for other player inputs to move forward in time for a true real time illusion).</p>
<p >Event happening in the <a class="el" href="classgame_1_1_client_game_manager.html" title="ClientGameManager is a class that inherits from GameManager by adding the visual part and specific im...">game::ClientGameManager</a> only happens on the client-side, no need to implement them in the <a class="el" href="classgame_1_1_client.html" title="Client is an interface of a player game manager and the net client interface (receive and send packet...">game::Client</a>. </p>
<h1><a class="anchor" id="sqlite"></a>
SQLite</h1>
<p >To debug efficiently the missbehavior of the netcode, the framework is providing a SQLite database allowing to review the last session. To use it, please enable ENABLE_SQLITE_STORE in your CMake options. You can use DB Browser for SQLite to open the databases created in the binaries folder. Each client will create its own database using its core::ClientId (for example Client85.db for a client who ClientId is 85). </p>
<h2><a class="anchor" id="input_dbg"></a>
Input debugging</h2>
<p >The SQLite database stores the input of all players per frame on each client and servers. Inputs are stored when the local client makes an input or when we receive a <a class="el" href="structgame_1_1_player_input_packet.html" title="PlayerInputPacket is a UDP Packet sent by the player client and then replicated by the server to all ...">game::PlayerInputPacket</a> from a remote client. The database will store:</p><ul>
<li>The frame when the input occured</li>
<li>The player number who did the input</li>
<li>The actual input (for the asteroid-like game, it is up, down, left, right and shoot). </li>
</ul>
<h2><a class="anchor" id="physics_state"></a>
Physics State debugging</h2>
<p >The SQLite database stores the physics state of all players when receiving a frame confirmation from the server. The database stores those data:</p><ul>
<li>local_frame, the current frame on the client side.</li>
<li>validate_frame, the validate frame from the server.</li>
<li>For each player: state_pN_local, state_pN_server (N being the player number) are the physics checksums. Those data allows to debug on all clients where the client desyncs from the server. </li>
</ul>
<h1><a class="anchor" id="miscellaneous"></a>
Miscellaneous</h1>
<h2><a class="anchor" id="angle"></a>
Angles</h2>
<p >Please use the provided <a class="el" href="classcore_1_1_degree.html" title="Degree is an utility class that describes degree angles (0 to 360). It can be easily converted to Rad...">core::Degree</a> class if you need angles. It allows to use the trigonometric functions (<a class="el" href="angle_8h.html#a793fdbbac78fb72747d508996f084e45" title="Sin is a function that calculates the sinus of a given angle.">core::Sin</a>, <a class="el" href="angle_8h.html#aacce12ff5fe06319f9b9844c6777beab" title="Cos is a function that calculates the cosinus of a given angle.">core::Cos</a>, <a class="el" href="angle_8h.html#a60c7ff6ad708884c22d913e2b77d09f3" title="Tan is a function that calculates the tangent of a given angle.">core::Tan</a>, <a class="el" href="angle_8h.html#aa1291a98d4f2e555027d93026a9b0b19" title="Asin is a function that calculates the angle of a given ratio.">core::Asin</a>, <a class="el" href="angle_8h.html#a0456705ff2b106f37b92b90947e36c84" title="Acos is a function that calculates the angle of a given ratio.">core::Acos</a>, <a class="el" href="angle_8h.html#a77b6600d4e588117427e265bf960c620" title="Atan is a function that calculates the angle of a given ratio.">core::Atan</a>, <a class="el" href="angle_8h.html#aadc69a1bfc9e8216fdd7247addb7e714" title="Atan2 is a function that calculates the angle of a given ratio between two parameters.">core::Atan2</a>) without worrying about conversions between degrees and radians. </p>
<h2><a class="anchor" id="assertion"></a>
Assertion</h2>
<p >To avoid crashes at random places due to invalid values, the core library allows to declare assertations (gpr_assert and gpr_warn) that can catch invalid values. For that to happen, you need to enable Gpr_Assert on the CMake options. When the expression is false, the assertion will throw an <a class="el" href="classcore_1_1_assert_exception.html" title="AssertException is an exception type used for the project assertation when the user need the applicat...">core::AssertException</a> that will quietly close the application (if you need to debug the stack data, please enable Gpr_Abort in the CMake options, it will use std::abort instead). You can also have a warning assertation, a warning that is not that important that you can decide if you want to abort or not (with the CMake option Gpr_Exit_On_Warning). </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
